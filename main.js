/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RubikCubeAlgos
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/RubikCubeAlgoSettings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  CUBE_COLOR: "#ff0",
  /* yellow for cube */
  ARROW_COLOR: "#08f"
  /* sky blue for arrows */
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Default cube color").setDesc("3 or 6 digit hex value. Starting value: #ff0 (yellow)").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.cubeColor).onChange(async (value) => {
      if (value.match("^#([a-f0-9]{3}){1,2}$")) {
        this.plugin.settings.cubeColor = value;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Default arrow color").setDesc("3 or 6 digit hex value. Starting value: #08f (sky blue)").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.arrowColor).onChange(async (value) => {
      if (value.match("^#([a-f0-9]{3}){1,2}$")) {
        this.plugin.settings.arrowColor = value;
        await this.plugin.saveSettings();
      }
    }));
  }
};

// src/RubikCubeAlgoCoordinatesPLL.ts
var DEFAULT = {
  WIDTH: 3,
  /* default rubik cube width */
  HEIGHT: 3
  /* default rubik cube height */
};
var PLL = class {
  constructor(settings) {
    this.COORDINATES = new Array();
    this.width = DEFAULT.WIDTH;
    this.height = DEFAULT.HEIGHT;
    if (settings.cubeColor) {
      this.cubeColor = settings.cubeColor;
    } else {
      this.cubeColor = DEFAULT_SETTINGS.CUBE_COLOR;
    }
    if (settings.arrowColor) {
      this.arrowColor = settings.arrowColor;
    } else {
      this.arrowColor = DEFAULT_SETTINGS.ARROW_COLOR;
    }
    this.arrows = "";
    this.codeBlockInterpretationSuccessful = true;
  }
  setDimension(w, h) {
    this.width = w;
    this.height = h;
  }
  setCubeColor(s) {
    this.cubeColor = "#" + s;
  }
  setArrowColor(s) {
    this.arrowColor = "#" + s;
  }
  setArrows(s) {
    this.arrows = s;
  }
  toString() {
    return "pll[cubeClr'" + this.cubeColor + "',arrowColor'" + this.arrowColor + "',arrows'" + this.arrows + "']";
  }
  interpretCodeBlock(rows) {
    if (rows.length === 0) {
      return this.fuckThisShitUp("[no input]", "at least 1 parameter needed: 'dimension/cubeColor/arrowColor/arrows'");
    }
    for (let r = 0; r < rows.length; r++) {
      let row = rows[r];
      if (row.startsWith("dimension:")) {
        if (!row.match("^dimension:\\d+,\\d+( //.*)?")) {
          return this.fuckThisShitUp(row, 'invalid dimension, expected "dimension:[2-10],[2-10]" // optional comment goes here');
        }
        let wXh = row.split(" ")[0].trim().replace("dimension:", "");
        let wXhSplit = wXh.split(",");
        let w = wXhSplit[0];
        let h = wXhSplit[1];
        if (w < 2 || h < 2 || w > 10 || h > 10) {
          return this.fuckThisShitUp(row, "invalid dimensions - expected: 2 < width/height < 10");
        }
        this.setDimension(w, h);
      } else if (row.match("^cubeColor:([a-f0-9]{3}){1,2}( //.*)?")) {
        let newCubClr = row.split(" ")[0].trim().replace("cubeColor:", "");
        this.setCubeColor(newCubClr);
      } else if (row.match("^arrowColor:([a-f0-9]{3}){1,2}( //.*)?")) {
        let newAroClr = row.split(" ")[0].trim().replace("arrowColor:", "");
        this.setArrowColor(newAroClr);
      } else if (row.match("^arrows:\\d+(\\.\\d+)?(-|\\+)\\d+(\\.\\d+)?(,\\d+(\\.\\d+)?(-|\\+)\\d+(\\.\\d+)?)*( //.*)?")) {
        let newArrows = row.split(" ")[0].trim().replace("arrows:", "");
        this.setArrows(newArrows);
      } else {
        return this.fuckThisShitUp(row, "unexpected input, expected: 'dimension', 'cubeColor', 'arrowColor' or 'arrows'");
      }
    }
    this.calculateCoordinates();
  }
  calculateCoordinates() {
    this.COORDINATES[0] = [];
    let index = 1;
    for (let h = 0; h < this.height; h++) {
      for (let w = 0; w < this.width; w++) {
        this.COORDINATES[index++] = [w * 100 + 50, h * 100 + 50];
      }
    }
  }
  fuckThisShitUp(mandatoryLastLineNotInterpretable, optionalReasonForFailure) {
    this.codeBlockInterpretationSuccessful = false;
    this.lastNonInterpretableLine = mandatoryLastLineNotInterpretable;
    if (optionalReasonForFailure) {
      this.reasonForFailure = optionalReasonForFailure;
    }
    console.log('Unexpected input: "' + mandatoryLastLineNotInterpretable + '"');
  }
  getCubeSize() {
    let wXh = [this.width * 100, this.height * 100];
    return wXh;
  }
  getArrowCoordinates() {
    let ARROWS = new Array();
    let allArrowCoords = this.arrows.split(",").filter((x) => x.length > 0);
    let index = 0;
    let isDoubleSided = false;
    for (let i = 0; i < allArrowCoords.length; i++) {
      isDoubleSided = false;
      let singleArrowCoords = allArrowCoords[i];
      let singleArrowCoordsFrom;
      let singleArrowCoordsTo;
      if (singleArrowCoords.match("\\d-\\d")) {
        let singleArrowCoordsSplit = singleArrowCoords.split("-");
        singleArrowCoordsFrom = singleArrowCoordsSplit[0];
        singleArrowCoordsTo = singleArrowCoordsSplit[1];
      } else {
        let singleArrowCoordsSplit = singleArrowCoords.split("+");
        singleArrowCoordsFrom = singleArrowCoordsSplit[0];
        singleArrowCoordsTo = singleArrowCoordsSplit[1];
        isDoubleSided = true;
      }
      if (singleArrowCoordsFrom === singleArrowCoordsTo) {
        this.fuckThisShitUp(singleArrowCoords, "arrow is pointing to its starting point");
        continue;
      }
      let arrowStart;
      let arrowEnd;
      if (singleArrowCoordsFrom.match("^[0-9]+$")) {
        arrowStart = this.COORDINATES[singleArrowCoordsFrom];
      } else {
        let semanticVersion = singleArrowCoordsFrom.split(".");
        let major = +semanticVersion[0];
        let minor = +semanticVersion[1];
        let c = (major - 1) * this.width + minor;
        arrowStart = this.COORDINATES[c];
      }
      if (singleArrowCoordsTo.match("^[0-9]+$")) {
        arrowEnd = this.COORDINATES[singleArrowCoordsTo];
      } else {
        let semanticVersion = singleArrowCoordsTo.split(".");
        let major = +semanticVersion[0];
        let minor = +semanticVersion[1];
        let c = (major - 1) * this.width + minor;
        arrowEnd = this.COORDINATES[c];
      }
      ARROWS[index++] = [arrowStart, arrowEnd];
      if (isDoubleSided) {
        ARROWS[index++] = [arrowEnd, arrowStart];
      }
    }
    return ARROWS;
  }
};

// src/main.ts
var RubikCubeAlgos = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor("rubikCubePLL", (source, el, ctx) => {
      const rows = source.split("\n").filter((row) => row.length > 0);
      let pllData = new PLL(this.settings);
      pllData.interpretCodeBlock(rows);
      let widthXheight = pllData.getCubeSize();
      let ARROWS = pllData.getArrowCoordinates();
      if (false === pllData.codeBlockInterpretationSuccessful) {
        el.createEl("div", { text: "--- Rubik Cube PLL pattern interpretation failed ---" });
        el.createEl("div", { text: "Faulty input:" });
        let explanationDiv = el.createEl("div");
        explanationDiv.createEl("b", { text: '"' + pllData.lastNonInterpretableLine + '"', cls: "rubik-cube-warning-text" });
        if (pllData.reasonForFailure) {
          explanationDiv.createEl("div", { text: "Reason: " + pllData.reasonForFailure });
        }
        return;
      }
      let w = widthXheight[0];
      let h = widthXheight[1];
      let mainSvg = el.createSvg("svg", { attr: { viewBox: "0 0 " + w + " " + h, width: w, height: h }, cls: "rubik-cube-pll" });
      let defs = mainSvg.createSvg("defs");
      let marker = defs.createSvg("marker", { attr: { id: "arrowhead" + pllData.arrowColor, markerWidth: "10", markerHeight: "7", refX: "9", refY: "3.5", orient: "auto" } });
      marker.createSvg("polygon", { attr: { points: "0 0, 10 3.5, 0 7", fill: pllData.arrowColor } });
      mainSvg.createSvg("rect", { attr: { fill: pllData.cubeColor }, cls: "rubik-cube-pll-rect" });
      for (let x = 100; x < w; x += 100) {
        mainSvg.createSvg("line", { attr: { x1: x, x2: x, y1: 0, y2: h }, cls: "rubik-cube-pll-line-grid" });
      }
      for (let y = 100; y < h; y += 100) {
        mainSvg.createSvg("line", { attr: { x1: 0, x2: w, y1: y, y2: y }, cls: "rubik-cube-pll-line-grid" });
      }
      for (let i = 0; i < ARROWS.length; i++) {
        let arrow = ARROWS[i];
        let arrowStartCoord = arrow[0];
        let arrowEndCoord = arrow[1];
        mainSvg.createSvg("line", {
          attr: {
            x1: arrowStartCoord[0],
            x2: arrowEndCoord[0],
            y1: arrowStartCoord[1],
            y2: arrowEndCoord[1],
            "marker-end": "url(#arrowhead" + pllData.arrowColor + ")",
            stroke: pllData.arrowColor
          },
          cls: "rubik-cube-pll-line-arrow"
        });
      }
    });
    const codeblockTemplatePLL = "```rubikCubePLL\ndimension:3,3 // width,height\ncubeColor:ff0 // yellow cube\narrowColor:08f // sky blue arrows\narrows:1-3,7+9\n```";
    this.addCommand({
      id: "RubikCubeAlgo-add-codeblock-template-3x3-PLL",
      name: "Add codeblock template: 3x3 PLL",
      editorCallback: (editor, view) => {
        editor.replaceSelection(codeblockTemplatePLL);
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    console.log("load settings: " + this.settings);
  }
  async saveSettings() {
    console.log("save settings: " + this.settings);
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL1J1YmlrQ3ViZUFsZ29TZXR0aW5ncy50cyIsICJzcmMvUnViaWtDdWJlQWxnb0Nvb3JkaW5hdGVzUExMLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBFZGl0b3IsIE1hcmtkb3duVmlldywgUGx1Z2lufSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIFJ1YmlrQ3ViZUFsZ29TZXR0aW5ncywgU2FtcGxlU2V0dGluZ1RhYiB9IGZyb20gXCIuL1J1YmlrQ3ViZUFsZ29TZXR0aW5nc1wiO1xyXG5pbXBvcnQgeyBQTEwgfSBmcm9tIFwiLi9SdWJpa0N1YmVBbGdvQ29vcmRpbmF0ZXNQTExcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1YmlrQ3ViZUFsZ29zIGV4dGVuZHMgUGx1Z2luIHtcclxuXHJcblx0c2V0dGluZ3M6IFJ1YmlrQ3ViZUFsZ29TZXR0aW5ncztcclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cdFx0XHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpOyBcclxuXHJcblx0XHR0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoJ3J1YmlrQ3ViZVBMTCcsIChzb3VyY2U6c3RyaW5nLCBlbCwgY3R4KSA9PiB7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJz4+IHJ1YmlrQ3ViZVBMTCcpO1xyXG5cdFx0XHRjb25zdCByb3dzID0gc291cmNlLnNwbGl0KCdcXG4nKS5maWx0ZXIoKHJvdykgPT4gcm93Lmxlbmd0aCA+IDApO1xyXG5cclxuXHRcdFx0bGV0IHBsbERhdGEgPSBuZXcgUExMKHRoaXMuc2V0dGluZ3MpOyBcclxuXHRcdFx0cGxsRGF0YS5pbnRlcnByZXRDb2RlQmxvY2socm93cyk7IFxyXG5cdFx0XHRsZXQgd2lkdGhYaGVpZ2h0ID0gcGxsRGF0YS5nZXRDdWJlU2l6ZSgpO1xyXG5cdFx0XHRsZXQgQVJST1dTID0gcGxsRGF0YS5nZXRBcnJvd0Nvb3JkaW5hdGVzKCk7XHJcblxyXG5cdFx0XHRpZiAoZmFsc2UgPT09IHBsbERhdGEuY29kZUJsb2NrSW50ZXJwcmV0YXRpb25TdWNjZXNzZnVsKXtcclxuXHRcdFx0XHRlbC5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiBcIi0tLSBSdWJpayBDdWJlIFBMTCBwYXR0ZXJuIGludGVycHJldGF0aW9uIGZhaWxlZCAtLS1cIiB9KTtcclxuXHRcdFx0XHRlbC5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiAnRmF1bHR5IGlucHV0OicgfSk7XHJcblx0XHRcdFx0bGV0IGV4cGxhbmF0aW9uRGl2ID0gZWwuY3JlYXRlRWwoJ2RpdicpO1xyXG5cdFx0XHRcdGV4cGxhbmF0aW9uRGl2LmNyZWF0ZUVsKCdiJywgeyB0ZXh0OiAnXCInK3BsbERhdGEubGFzdE5vbkludGVycHJldGFibGVMaW5lKydcIicsIGNsczoncnViaWstY3ViZS13YXJuaW5nLXRleHQnICB9KTtcclxuXHRcdFx0XHRpZiAocGxsRGF0YS5yZWFzb25Gb3JGYWlsdXJlKSB7XHJcblx0XHRcdFx0XHRleHBsYW5hdGlvbkRpdi5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiAnUmVhc29uOiAnK3BsbERhdGEucmVhc29uRm9yRmFpbHVyZX0pO1xyXG5cdFx0XHRcdH1cdFx0XHRcdFxyXG5cdFx0XHRcdHJldHVybjsgXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGxldCB3ID0gd2lkdGhYaGVpZ2h0WzBdOyBcclxuXHRcdFx0bGV0IGggPSB3aWR0aFhoZWlnaHRbMV07IFxyXG5cdFx0XHRsZXQgbWFpblN2ZyA9IGVsLmNyZWF0ZVN2Zygnc3ZnJywgeyBhdHRyOiB7IHZpZXdCb3g6JzAgMCAnK3crJyAnK2gsIHdpZHRoOncsIGhlaWdodDpoIH0sIGNsczogXCJydWJpay1jdWJlLXBsbFwiIH0pO1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IGRlZnMgPSBtYWluU3ZnLmNyZWF0ZVN2ZygnZGVmcycpO1xyXG5cdFx0XHRsZXQgbWFya2VyID0gZGVmcy5jcmVhdGVTdmcoJ21hcmtlcicsIHsgYXR0cjoge2lkOlwiYXJyb3doZWFkXCIrcGxsRGF0YS5hcnJvd0NvbG9yLCBtYXJrZXJXaWR0aDpcIjEwXCIsIG1hcmtlckhlaWdodDpcIjdcIiwgcmVmWDpcIjlcIiwgcmVmWTpcIjMuNVwiLCBvcmllbnQ6XCJhdXRvXCJ9fSk7XHJcblx0XHRcdG1hcmtlci5jcmVhdGVTdmcoJ3BvbHlnb24nLCB7IGF0dHI6IHtwb2ludHM6XCIwIDAsIDEwIDMuNSwgMCA3XCIgLCBmaWxsOnBsbERhdGEuYXJyb3dDb2xvcn19KTtcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHQvKiBZZWxsb3cgYmFzZSByZWN0ICovXHJcblx0XHRcdG1haW5TdmcuY3JlYXRlU3ZnKCdyZWN0JywgeyBhdHRyOiB7IGZpbGw6cGxsRGF0YS5jdWJlQ29sb3IgfSwgY2xzOiBcInJ1YmlrLWN1YmUtcGxsLXJlY3RcIiB9KTsgXHJcblx0XHRcdFxyXG5cdFx0XHQvKlxyXG5cdFx0XHQgKiBCYWNrZ3JvdW5kIGdyaWQ7IHN0YXRpYywgdW5yZXNwb25zaXZlLCBibGFjayByZWN0YW5ndWxhciBsaW5lc1xyXG5cdFx0XHQgKi9cclxuXHRcdFx0LyogVmVydGljYWwgbGluZXMgKi9cclxuXHRcdFx0Zm9yIChsZXQgeDpudW1iZXIgPSAxMDA7IHggPCB3OyB4Kz0xMDApIHtcclxuXHRcdFx0XHRtYWluU3ZnLmNyZWF0ZVN2ZygnbGluZScsIHsgYXR0cjogeyB4MTp4LCB4Mjp4LCB5MTowLCB5MjpoIH0sIGNsczogXCJydWJpay1jdWJlLXBsbC1saW5lLWdyaWRcIiB9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKiBIb3Jpem9udGFsIGxpbmVzICovIFxyXG5cdFx0XHRmb3IgKGxldCB5Om51bWJlciA9IDEwMDsgeSA8IGg7IHkrPTEwMCkge1xyXG5cdFx0XHRcdG1haW5TdmcuY3JlYXRlU3ZnKCdsaW5lJywgeyBhdHRyOiB7IHgxOjAsIHgyOncsIHkxOnksIHkyOnkgfSwgY2xzOiBcInJ1YmlrLWN1YmUtcGxsLWxpbmUtZ3JpZFwiIH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgQVJST1dTLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IGFycm93ID0gQVJST1dTW2ldO1xyXG5cdFx0XHRcdGxldCBhcnJvd1N0YXJ0Q29vcmQgPSBhcnJvd1swXTtcclxuXHRcdFx0XHRsZXQgYXJyb3dFbmRDb29yZCA9IGFycm93WzFdO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJBcnJvdyBnb2VzIGZyb20gXCIrYXJyb3dTdGFydENvb3JkK1wiIHRvIFwiK2Fycm93RW5kQ29vcmQpO1xyXG5cdFx0XHRcdG1haW5TdmcuY3JlYXRlU3ZnKCdsaW5lJywgeyBhdHRyOiB7IHgxOmFycm93U3RhcnRDb29yZFswXSwgeDI6YXJyb3dFbmRDb29yZFswXSwgeTE6YXJyb3dTdGFydENvb3JkWzFdLCB5MjphcnJvd0VuZENvb3JkWzFdLFxyXG5cdFx0XHRcdFx0XHRcdCdtYXJrZXItZW5kJzondXJsKCNhcnJvd2hlYWQnK3BsbERhdGEuYXJyb3dDb2xvcisnKScsIHN0cm9rZTpwbGxEYXRhLmFycm93Q29sb3IsICB9LFxyXG5cdFx0XHRcdGNsczogXCJydWJpay1jdWJlLXBsbC1saW5lLWFycm93XCIgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCc8PCBydWJpa0N1YmVQTEwnKTtcdFx0XHJcblx0XHR9KTtcclxuXHRcdFxyXG5cdFx0Y29uc3QgY29kZWJsb2NrVGVtcGxhdGVQTEw6c3RyaW5nID0gXHJcbidgYGBydWJpa0N1YmVQTExcXG4nK1xyXG4nZGltZW5zaW9uOjMsMyAvLyB3aWR0aCxoZWlnaHRcXG4nK1xyXG4nY3ViZUNvbG9yOmZmMCAvLyB5ZWxsb3cgY3ViZVxcbicrXHJcbidhcnJvd0NvbG9yOjA4ZiAvLyBza3kgYmx1ZSBhcnJvd3NcXG4nK1xyXG4nYXJyb3dzOjEtMyw3KzlcXG4nK1xyXG4nYGBgJztcclxuXHJcblx0XHQvLyBBZGQgUnViaWsgQ3ViZSBjb2RlYmxvY2sgdGVtcGxhdGU6IFxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6ICdSdWJpa0N1YmVBbGdvLWFkZC1jb2RlYmxvY2stdGVtcGxhdGUtM3gzLVBMTCcsXHRcclxuXHRcdFx0bmFtZTogJ0FkZCBjb2RlYmxvY2sgdGVtcGxhdGU6IDN4MyBQTEwnLFxyXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcclxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihjb2RlYmxvY2tUZW1wbGF0ZVBMTCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXHJcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcblx0XHQvLyBXaGVuIHJlZ2lzdGVyaW5nIGludGVydmFscywgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGludGVydmFsIHdoZW4gdGhlIHBsdWdpbiBpcyBkaXNhYmxlZC5cclxuXHRcdC8vdGhpcy5yZWdpc3RlckludGVydmFsKHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiBjb25zb2xlLmxvZygnc2V0SW50ZXJ2YWwnKSwgNSAqIDYwICogMTAwMCkpO1xyXG5cdFx0XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdG9udW5sb2FkKCkge1xyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSBhcyBQYXJ0aWFsPFJ1YmlrQ3ViZUFsZ29zU2V0dGluZ3M+KTtcclxuXHRcdGNvbnNvbGUubG9nKCdsb2FkIHNldHRpbmdzOiAnICsgdGhpcy5zZXR0aW5ncylcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuXHRcdGNvbnNvbGUubG9nKCdzYXZlIHNldHRpbmdzOiAnICsgdGhpcy5zZXR0aW5ncylcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcblx0fVxyXG5cclxufVxyXG4iLCAiaW1wb3J0IHtBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSdWJpa0N1YmVBbGdvU2V0dGluZ3Mge1xyXG5cdGN1YmVDb2xvcjogc3RyaW5nO1xyXG5cdGFycm93Q29sb3I6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFJ1YmlrQ3ViZUFsZ29TZXR0aW5ncyA9IHtcclxuXHRDVUJFX0NPTE9SOiAnI2ZmMCcsIC8qIHllbGxvdyBmb3IgY3ViZSAqL1xyXG5cdEFSUk9XX0NPTE9SOiAnIzA4ZicgLyogc2t5IGJsdWUgZm9yIGFycm93cyAqL1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogTXlQbHVnaW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHR9XHJcblxyXG5cdGRpc3BsYXkoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcclxuXHJcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZSgnRGVmYXVsdCBjdWJlIGNvbG9yJylcclxuXHRcdFx0LnNldERlc2MoJzMgb3IgNiBkaWdpdCBoZXggdmFsdWUuIFN0YXJ0aW5nIHZhbHVlOiAjZmYwICh5ZWxsb3cpJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHNlY3JldCcpXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmN1YmVDb2xvcilcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRpZiAodmFsdWUubWF0Y2goJ14jKFthLWYwLTldezN9KXsxLDJ9JCcpKXtcclxuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuY3ViZUNvbG9yID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pKTtcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZSgnRGVmYXVsdCBhcnJvdyBjb2xvcicpXHJcblx0XHRcdC5zZXREZXNjKCczIG9yIDYgZGlnaXQgaGV4IHZhbHVlLiBTdGFydGluZyB2YWx1ZTogIzA4ZiAoc2t5IGJsdWUpJylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHNlY3JldCcpXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmFycm93Q29sb3IpIFxyXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdGlmICh2YWx1ZS5tYXRjaCgnXiMoW2EtZjAtOV17M30pezEsMn0kJykpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hcnJvd0NvbG9yID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pKTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIFJ1YmlrQ3ViZUFsZ29zU2V0dGluZ3MgfSBmcm9tIFwiLi9SdWJpa0N1YmVBbGdvU2V0dGluZ3NcIjtcclxuXHJcbmNvbnN0IERFRkFVTFQgPSB7XHJcblx0V0lEVEg6IDMsIC8qIGRlZmF1bHQgcnViaWsgY3ViZSB3aWR0aCAqL1xyXG5cdEhFSUdIVDogMyAvKiBkZWZhdWx0IHJ1YmlrIGN1YmUgaGVpZ2h0ICovXHJcbn0gYXMgY29uc3Q7IFxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBQTEwge1xyXG5cdENPT1JESU5BVEVTO1xyXG5cdHdpZHRoOm51bWJlcjtcclxuXHRoZWlnaHQ6bnVtYmVyO1xyXG5cdGN1YmVDb2xvcjpzdHJpbmc7XHJcblx0YXJyb3dDb2xvcjpzdHJpbmc7XHJcblx0YXJyb3dzOnN0cmluZztcclxuXHRjb2RlQmxvY2tJbnRlcnByZXRhdGlvblN1Y2Nlc3NmdWw6Ym9vbGVhbjtcclxuXHRsYXN0Tm9uSW50ZXJwcmV0YWJsZUxpbmU6c3RyaW5nOyBcclxuXHRyZWFzb25Gb3JGYWlsdXJlOnN0cmluZztcclxuXHJcblx0Y29uc3RydWN0b3Ioc2V0dGluZ3M6UnViaWtDdWJlQWxnb3NTZXR0aW5ncykge1xyXG5cdFx0dGhpcy5DT09SRElOQVRFUyA9IG5ldyBBcnJheSgpO1xyXG5cdFx0dGhpcy53aWR0aCA9IERFRkFVTFQuV0lEVEg7XHJcblx0XHR0aGlzLmhlaWdodCA9IERFRkFVTFQuSEVJR0hUO1xyXG5cdFx0XHJcblx0XHRpZiAoc2V0dGluZ3MuY3ViZUNvbG9yKXtcclxuXHRcdFx0dGhpcy5jdWJlQ29sb3IgPSBzZXR0aW5ncy5jdWJlQ29sb3I7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmN1YmVDb2xvciA9IERFRkFVTFRfU0VUVElOR1MuQ1VCRV9DT0xPUjtcclxuXHRcdH1cclxuXHRcdGlmIChzZXR0aW5ncy5hcnJvd0NvbG9yKXtcclxuXHRcdFx0dGhpcy5hcnJvd0NvbG9yID0gc2V0dGluZ3MuYXJyb3dDb2xvcjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuYXJyb3dDb2xvciA9IERFRkFVTFRfU0VUVElOR1MuQVJST1dfQ09MT1I7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHRoaXMuYXJyb3dzID0gXCJcIjtcclxuXHRcdHRoaXMuY29kZUJsb2NrSW50ZXJwcmV0YXRpb25TdWNjZXNzZnVsPXRydWU7XHJcblx0XHRcclxuXHRcdFxyXG5cdH1cclxuXHRwcml2YXRlIHNldERpbWVuc2lvbih3Om51bWJlcixoOm51bWJlcik6dm9pZCB7XHJcblx0XHR0aGlzLndpZHRoPXc7XHJcblx0XHR0aGlzLmhlaWdodD1oO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIm5ldyBkaW1lbnNpb25zOiBcIit3K1wiLFwiK2gpO1xyXG5cdH1cclxuXHRwcml2YXRlIHNldEN1YmVDb2xvcihzOnN0cmluZyk6dm9pZCB7XHJcblx0XHR0aGlzLmN1YmVDb2xvciA9ICcjJytzO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIm5ldyBjdWJlIGNvbG9yOiAnXCIrcytcIidcIik7XHJcblx0fVxyXG5cdHByaXZhdGUgc2V0QXJyb3dDb2xvcihzOnN0cmluZyk6dm9pZCB7XHJcblx0XHR0aGlzLmFycm93Q29sb3IgPSAnIycrcztcclxuXHRcdC8vY29uc29sZS5sb2coXCJuZXcgYXJyb3cgY29sb3I6ICdcIitzK1wiJ1wiKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzZXRBcnJvd3MoczpzdHJpbmcpOnZvaWQge1xyXG5cdFx0dGhpcy5hcnJvd3MgPSBzO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIm5ldyBhcnJvd3M6ICdcIitzK1wiJ1wiKTtcclxuXHR9XHJcblx0dG9TdHJpbmcoKTpzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwicGxsW2N1YmVDbHInXCIrdGhpcy5jdWJlQ29sb3IrXCInLGFycm93Q29sb3InXCIrdGhpcy5hcnJvd0NvbG9yK1wiJyxhcnJvd3MnXCIrdGhpcy5hcnJvd3MrXCInXVwiXHJcblx0fVxyXG5cdGludGVycHJldENvZGVCbG9jayhyb3dzOnN0cmluZ1tdKTp2b2lkIHtcclxuXHRcdGlmIChyb3dzLmxlbmd0aCA9PT0wKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnVja1RoaXNTaGl0VXAoXCJbbm8gaW5wdXRdXCIsXCJhdCBsZWFzdCAxIHBhcmFtZXRlciBuZWVkZWQ6ICdkaW1lbnNpb24vY3ViZUNvbG9yL2Fycm93Q29sb3IvYXJyb3dzJ1wiKTtcclxuXHRcdH1cclxuXHRcdC8vIGNvbnNvbGUubG9nKCdwbGwgYmVmb3JlOiAnK3RoaXMudG9TdHJpbmcoKSk7XHRcdFxyXG5cdFx0Zm9yIChsZXQgciA9IDA7IHIgPCByb3dzLmxlbmd0aDsgcisrKSB7XHJcblx0XHRcdGxldCByb3cgPSByb3dzW3JdO1xyXG5cdFx0XHRpZiAocm93LnN0YXJ0c1dpdGgoJ2RpbWVuc2lvbjonKSkge1xyXG5cdFx0XHRcdGlmICghcm93Lm1hdGNoKCdeZGltZW5zaW9uOlxcXFxkKyxcXFxcZCsoIC8vLiopPycpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5mdWNrVGhpc1NoaXRVcChyb3csJ2ludmFsaWQgZGltZW5zaW9uLCBleHBlY3RlZCBcImRpbWVuc2lvbjpbMi0xMF0sWzItMTBdXCIgLy8gb3B0aW9uYWwgY29tbWVudCBnb2VzIGhlcmUnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGV0IHdYaCA9IHJvdy5zcGxpdCgnICcpWzBdLnRyaW0oKS5yZXBsYWNlKCdkaW1lbnNpb246JywnJyk7XHJcblx0XHRcdFx0bGV0IHdYaFNwbGl0ID0gd1hoLnNwbGl0KCcsJyk7XHJcblx0XHRcdFx0bGV0IHc9IHdYaFNwbGl0WzBdO1xyXG5cdFx0XHRcdGxldCBoPSB3WGhTcGxpdFsxXTtcclxuXHRcdFx0XHRpZiAodzwyfHxoPDJ8fHc+MTB8fGg+MTApe1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZnVja1RoaXNTaGl0VXAocm93LCdpbnZhbGlkIGRpbWVuc2lvbnMgLSBleHBlY3RlZDogMiA8IHdpZHRoL2hlaWdodCA8IDEwJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuc2V0RGltZW5zaW9uKHcsaCk7XHJcblx0XHRcdH0gZWxzZSBpZiAocm93Lm1hdGNoKCdeY3ViZUNvbG9yOihbYS1mMC05XXszfSl7MSwyfSggLy8uKik/JykpIHtcclxuXHRcdFx0XHRsZXQgbmV3Q3ViQ2xyID0gcm93LnNwbGl0KCcgJylbMF0udHJpbSgpLnJlcGxhY2UoJ2N1YmVDb2xvcjonLCcnKTtcclxuXHRcdFx0XHR0aGlzLnNldEN1YmVDb2xvcihuZXdDdWJDbHIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJvdy5tYXRjaCgnXmFycm93Q29sb3I6KFthLWYwLTldezN9KXsxLDJ9KCAvLy4qKT8nKSkge1xyXG5cdFx0XHRcdGxldCBuZXdBcm9DbHIgPSByb3cuc3BsaXQoJyAnKVswXS50cmltKCkucmVwbGFjZSgnYXJyb3dDb2xvcjonLCcnKVxyXG5cdFx0XHRcdHRoaXMuc2V0QXJyb3dDb2xvcihuZXdBcm9DbHIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJvdy5tYXRjaCgnXmFycm93czpcXFxcZCsoXFxcXC5cXFxcZCspPygtfFxcXFwrKVxcXFxkKyhcXFxcLlxcXFxkKyk/KCxcXFxcZCsoXFxcXC5cXFxcZCspPygtfFxcXFwrKVxcXFxkKyhcXFxcLlxcXFxkKyk/KSooIC8vLiopPycpKSB7XHJcblx0XHRcdFx0bGV0IG5ld0Fycm93cyA9IHJvdy5zcGxpdCgnICcpWzBdLnRyaW0oKS5yZXBsYWNlKCdhcnJvd3M6JywnJylcclxuXHRcdFx0XHR0aGlzLnNldEFycm93cyhuZXdBcnJvd3MpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmZ1Y2tUaGlzU2hpdFVwKHJvdywgXCJ1bmV4cGVjdGVkIGlucHV0LCBleHBlY3RlZDogJ2RpbWVuc2lvbicsICdjdWJlQ29sb3InLCAnYXJyb3dDb2xvcicgb3IgJ2Fycm93cydcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cdFxyXG5cdFx0dGhpcy5jYWxjdWxhdGVDb29yZGluYXRlcygpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBjYWxjdWxhdGVDb29yZGluYXRlcygpe1xyXG5cdFx0dGhpcy5DT09SRElOQVRFU1swXSA9IFtdO1xyXG5cdFx0bGV0IGluZGV4Om51bWJlcj0xO1xyXG5cdFx0LyogcmV2ZXJzZSBsb29wIG9yZGVyIHRvIGdpdmUgeCBjb29yZGluYXRlcyBtb3JlIHByaW9yaXR5ICovXHJcblx0XHRmb3IgKGxldCBoID0gMDsgaCA8IHRoaXMuaGVpZ2h0OyBoKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgdyA9IDA7IHcgPCB0aGlzLndpZHRoOyB3KyspIHtcclxuXHRcdFx0XHR0aGlzLkNPT1JESU5BVEVTW2luZGV4KytdID0gW3cqMTAwICsgNTAsIGgqMTAwICsgNTBdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHByaXZhdGUgZnVja1RoaXNTaGl0VXAobWFuZGF0b3J5TGFzdExpbmVOb3RJbnRlcnByZXRhYmxlOnN0cmluZywgb3B0aW9uYWxSZWFzb25Gb3JGYWlsdXJlOnN0cmluZyl7XHJcblx0XHR0aGlzLmNvZGVCbG9ja0ludGVycHJldGF0aW9uU3VjY2Vzc2Z1bD1mYWxzZTtcclxuXHRcdHRoaXMubGFzdE5vbkludGVycHJldGFibGVMaW5lPW1hbmRhdG9yeUxhc3RMaW5lTm90SW50ZXJwcmV0YWJsZTtcclxuXHRcdGlmIChvcHRpb25hbFJlYXNvbkZvckZhaWx1cmUpIHtcclxuXHRcdFx0dGhpcy5yZWFzb25Gb3JGYWlsdXJlPW9wdGlvbmFsUmVhc29uRm9yRmFpbHVyZTtcclxuXHRcdH1cclxuXHRcdGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkIGlucHV0OiBcIicrbWFuZGF0b3J5TGFzdExpbmVOb3RJbnRlcnByZXRhYmxlKydcIicpO1xyXG5cdH1cclxuXHRnZXRDdWJlU2l6ZSgpe1xyXG5cdFx0bGV0IHdYaCA9IFt0aGlzLndpZHRoKjEwMCwgdGhpcy5oZWlnaHQqMTAwXTtcclxuXHRcdHJldHVybiB3WGg7XHJcblx0fVxyXG5cdGdldEFycm93Q29vcmRpbmF0ZXMoKSB7XHJcblx0XHQvL2NvbnNvbGUubG9nKCc+PiBnZXRBcnJvd0Nvb3JkaW5hdGVzLCAnICsgdGhpcy5DT09SRElOQVRFUyk7XHJcblx0XHRsZXQgQVJST1dTID0gbmV3IEFycmF5KCk7XHJcblx0XHRsZXQgYWxsQXJyb3dDb29yZHMgPSB0aGlzLmFycm93cy5zcGxpdCgnLCcpLmZpbHRlcigoeCkgPT4geC5sZW5ndGggPiAwKTtcclxuXHRcdGxldCBpbmRleDpudW1iZXIgPSAwO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIkFycm93cyB0byBpbnRlcnByZXQ6IFwiK2FsbEFycm93Q29vcmRzKTtcclxuXHRcdGxldCBpc0RvdWJsZVNpZGVkOmJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYWxsQXJyb3dDb29yZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aXNEb3VibGVTaWRlZCA9IGZhbHNlO1xyXG5cdFx0XHRsZXQgc2luZ2xlQXJyb3dDb29yZHM6c3RyaW5nID0gYWxsQXJyb3dDb29yZHNbaV07XHJcblx0XHRcdGxldCBzaW5nbGVBcnJvd0Nvb3Jkc0Zyb206c3RyaW5nOyBcclxuXHRcdFx0bGV0IHNpbmdsZUFycm93Q29vcmRzVG86c3RyaW5nO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHNpbmdsZUFycm93Q29vcmRzLm1hdGNoKCdcXFxcZC1cXFxcZCcpKSB7XHJcblx0XHRcdFx0bGV0IHNpbmdsZUFycm93Q29vcmRzU3BsaXQgPSBzaW5nbGVBcnJvd0Nvb3Jkcy5zcGxpdCgnLScpO1xyXG5cdFx0XHRcdHNpbmdsZUFycm93Q29vcmRzRnJvbSA9IHNpbmdsZUFycm93Q29vcmRzU3BsaXRbMF07XHJcblx0XHRcdFx0c2luZ2xlQXJyb3dDb29yZHNUbyA9IHNpbmdsZUFycm93Q29vcmRzU3BsaXRbMV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IHNpbmdsZUFycm93Q29vcmRzU3BsaXQgPSBzaW5nbGVBcnJvd0Nvb3Jkcy5zcGxpdCgnKycpO1xyXG5cdFx0XHRcdHNpbmdsZUFycm93Q29vcmRzRnJvbSA9IHNpbmdsZUFycm93Q29vcmRzU3BsaXRbMF07XHJcblx0XHRcdFx0c2luZ2xlQXJyb3dDb29yZHNUbyA9IHNpbmdsZUFycm93Q29vcmRzU3BsaXRbMV07XHJcblx0XHRcdFx0aXNEb3VibGVTaWRlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChzaW5nbGVBcnJvd0Nvb3Jkc0Zyb209PT1zaW5nbGVBcnJvd0Nvb3Jkc1RvKXtcclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIlNraXAgYXJyb3cgcG9pbnRpbmcgdG8gaXRzZWxmOiBcIitzaW5nbGVBcnJvd0Nvb3Jkc0Zyb20pO1xyXG5cdFx0XHRcdHRoaXMuZnVja1RoaXNTaGl0VXAoc2luZ2xlQXJyb3dDb29yZHMsJ2Fycm93IGlzIHBvaW50aW5nIHRvIGl0cyBzdGFydGluZyBwb2ludCcpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiLS0gQXJyb3cgZ29lcyBmcm9tICdcIitzaW5nbGVBcnJvd0Nvb3Jkc0Zyb20rXCInIHRvICdcIitzaW5nbGVBcnJvd0Nvb3Jkc1RvK1wiJ1wiKTtcclxuXHRcdFx0XHJcblx0XHRcdGxldCBhcnJvd1N0YXJ0O1xyXG5cdFx0XHRsZXQgYXJyb3dFbmQ7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2luZ2xlQXJyb3dDb29yZHNGcm9tLm1hdGNoKCdeWzAtOV0rJCcpKXtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCctLSBkOiAnICsgc2luZ2xlQXJyb3dDb29yZHNGcm9tKTtcclxuXHRcdFx0XHRhcnJvd1N0YXJ0ID0gdGhpcy5DT09SRElOQVRFU1tzaW5nbGVBcnJvd0Nvb3Jkc0Zyb21dO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBzZW1hbnRpY1ZlcnNpb24gPSBzaW5nbGVBcnJvd0Nvb3Jkc0Zyb20uc3BsaXQoJy4nKTtcclxuXHRcdFx0XHRsZXQgbWFqb3I6bnVtYmVyID0gK3NlbWFudGljVmVyc2lvblswXTtcclxuXHRcdFx0XHRsZXQgbWlub3I6bnVtYmVyID0gK3NlbWFudGljVmVyc2lvblsxXTtcclxuXHRcdFx0XHRsZXQgYzpudW1iZXIgPSAobWFqb3ItMSkqdGhpcy53aWR0aCArIG1pbm9yO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJy0tIGM6ICcgKyBjKTtcclxuXHRcdFx0XHRhcnJvd1N0YXJ0ID0gdGhpcy5DT09SRElOQVRFU1tjXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHNpbmdsZUFycm93Q29vcmRzVG8ubWF0Y2goJ15bMC05XSskJykpe1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJy0tIGQ6ICcgKyBzaW5nbGVBcnJvd0Nvb3Jkc1RvKTtcclxuXHRcdFx0XHRhcnJvd0VuZCA9IHRoaXMuQ09PUkRJTkFURVNbc2luZ2xlQXJyb3dDb29yZHNUb107XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IHNlbWFudGljVmVyc2lvbiA9IHNpbmdsZUFycm93Q29vcmRzVG8uc3BsaXQoJy4nKTtcclxuXHRcdFx0XHRsZXQgbWFqb3I6bnVtYmVyID0gK3NlbWFudGljVmVyc2lvblswXTtcclxuXHRcdFx0XHRsZXQgbWlub3I6bnVtYmVyID0gK3NlbWFudGljVmVyc2lvblsxXTtcclxuXHRcdFx0XHRsZXQgYzpudW1iZXIgPSAobWFqb3ItMSkqdGhpcy53aWR0aCArIG1pbm9yO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJy0tIGM6ICcgKyBjKTtcclxuXHRcdFx0XHRhcnJvd0VuZCA9IHRoaXMuQ09PUkRJTkFURVNbY107XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRBUlJPV1NbaW5kZXgrK10gPSBbIGFycm93U3RhcnQsIGFycm93RW5kIF07XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoaXNEb3VibGVTaWRlZCkgeyAvLyBhZGQgcmV2ZXJzZSBjb3B5XHJcblx0XHRcdFx0QVJST1dTW2luZGV4KytdID0gWyBhcnJvd0VuZCwgYXJyb3dTdGFydCBdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvL2NvbnNvbGUubG9nKCc8PCBnZXRBcnJvd0Nvb3JkaW5hdGVzLCAnICsgQVJST1dTKTtcclxuXHRcdHJldHVybiBBUlJPV1M7XHJcblx0fVxyXG59OyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBNEM7OztBQ0E1QyxzQkFBNkM7QUFRdEMsSUFBTSxtQkFBMEM7QUFBQSxFQUN0RCxZQUFZO0FBQUE7QUFBQSxFQUNaLGFBQWE7QUFBQTtBQUNkO0FBRU8sSUFBTSxtQkFBTixjQUErQixpQ0FBaUI7QUFBQSxFQUd0RCxZQUFZLEtBQVUsUUFBa0I7QUFDdkMsVUFBTSxLQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDZjtBQUFBLEVBRUEsVUFBZ0I7QUFDZixVQUFNLEVBQUMsWUFBVyxJQUFJO0FBRXRCLGdCQUFZLE1BQU07QUFFbEIsUUFBSSx3QkFBUSxXQUFXLEVBQ3JCLFFBQVEsb0JBQW9CLEVBQzVCLFFBQVEsdURBQXVELEVBQy9ELFFBQVEsVUFBUSxLQUNmLGVBQWUsbUJBQW1CLEVBQ2xDLFNBQVMsS0FBSyxPQUFPLFNBQVMsU0FBUyxFQUN2QyxTQUFTLE9BQU8sVUFBVTtBQUMxQixVQUFJLE1BQU0sTUFBTSx1QkFBdUIsR0FBRTtBQUN4QyxhQUFLLE9BQU8sU0FBUyxZQUFZO0FBQ2pDLGNBQU0sS0FB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
